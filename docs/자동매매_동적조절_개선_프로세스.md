# 🚀 자동매매 동적조절 개선 프로세스

## 📋 목차

1. [현재 상황 분석](#현재-상황-분석)
2. [개선 목표](#개선-목표)
3. [구현 단계](#구현-단계)
4. [기술적 상세](#기술적-상세)
5. [API 설계](#api-설계)
6. [테스트 계획](#테스트-계획)
7. [배포 및 모니터링](#배포-및-모니터링)

---

## 🔍 현재 상황 분석

### ❌ 현재 문제점

#### 1. **고정 포지션 크기**

```typescript
// src/auto-trading/service/AutoTradingService.ts
private calculatePositionSize(symbol: string, currentPrice: number): number {
  // TODO: 계좌 잔고를 확인하여 동적으로 계산
  // 현재는 고정 $100 노셔널 값 사용
  const notionalValue = 100; // USD
  const quantity = notionalValue / currentPrice;
  return quantity;
}
```

**문제점**:

- 계좌 잔고 무시
- 리스크 관리 없음
- 시장 상황 무시
- 수익/손실에 따른 조절 없음

#### 2. **고정 손절/익절**

```typescript
// 현재 설정
const stopLoss = currentPrice * (1 + 0.02); // 고정 2%
const takeProfit = currentPrice * (1 + 0.04); // 고정 4%
```

**문제점**:

- 시장 변동성 무시
- ATR 기반 동적 조절 없음
- 리스크/리워드 비율 고정

#### 3. **사용 가능한 기능**

- ✅ `FuturesService.getFuturesBalances()` - 잔고 조회 가능
- ✅ `TechnicalAnalysisController.calculatePositionSize()` - 리스크 기반 계산 API
- ❌ AutoTradingService에서 활용 안함

---

## 🎯 개선 목표

### 1. **동적 포지션 크기**

- 계좌 잔고 기반 계산
- 리스크 관리 비율 적용
- 시장 상황에 따른 조절
- Kelly Criterion 적용

### 2. **동적 손절/익절**

- ATR 기반 동적 계산
- 변동성에 따른 조절
- 리스크/리워드 비율 최적화

### 3. **실시간 설정 조절**

- API를 통한 실시간 설정 변경
- 웹 대시보드 연동
- 조건부 자동 조절

---

## 🛠️ 구현 단계

### **1단계: 기본 동적 포지션 크기 구현**

#### 1.1 환경변수 설정

```bash
# .env 파일 추가
# 포지션 크기 설정
POSITION_SIZE_TYPE=DYNAMIC          # FIXED | DYNAMIC
POSITION_SIZE_PERCENT=2             # 계좌 잔고의 2%
POSITION_SIZE_MAX_AMOUNT=1000       # 최대 $1000
POSITION_SIZE_MIN_AMOUNT=50         # 최소 $50

# 리스크 관리 설정
RISK_MANAGEMENT_ENABLED=true        # 리스크 관리 활성화
MAX_RISK_PER_TRADE=2               # 거래당 최대 리스크 2%
MAX_DAILY_RISK=5                   # 일일 최대 리스크 5%
```

#### 1.2 AutoTradingService 개선

```typescript
// src/auto-trading/service/AutoTradingService.ts
class AutoTradingService {
  private async calculateDynamicPositionSize(
    symbol: string,
    currentPrice: number,
  ): Promise<number> {
    // 1. 계좌 잔고 조회
    const balances = await this.futuresService.getFuturesBalances();
    const usdtBalance =
      balances.find((b) => b.asset === 'USDT')?.availableBalance || 0;

    // 2. 설정값 조회
    const positionType = this.configService.get(
      'POSITION_SIZE_TYPE',
      'DYNAMIC',
    );
    const percentage = this.configService.get('POSITION_SIZE_PERCENT', 2) / 100;
    const maxAmount = this.configService.get('POSITION_SIZE_MAX_AMOUNT', 1000);
    const minAmount = this.configService.get('POSITION_SIZE_MIN_AMOUNT', 50);

    if (positionType === 'FIXED') {
      return 100; // 기존 고정값
    }

    // 3. 동적 계산
    const calculatedAmount = usdtBalance * percentage;
    const finalAmount = Math.max(
      minAmount,
      Math.min(calculatedAmount, maxAmount),
    );
    const quantity = finalAmount / currentPrice;

    this.logger.log(
      `💰 [${symbol}] 동적 포지션 크기: ${usdtBalance}USD → ${finalAmount}USD (${quantity.toFixed(6)})`,
    );

    return quantity;
  }
}
```

### **2단계: ATR 기반 동적 손절/익절**

#### 2.1 ATR 계산 서비스

```typescript
// src/technical-analysis/service/TechnicalIndicatorService.ts
class TechnicalIndicatorService {
  async calculateATR(symbol: string, period: number = 14): Promise<number> {
    const candles = await this.candleRepository.findLatestCandles(
      symbol,
      'FUTURES',
      period + 1,
    );

    const trueRanges = [];
    for (let i = 1; i < candles.length; i++) {
      const high = candles[i].high;
      const low = candles[i].low;
      const prevClose = candles[i - 1].close;

      const tr1 = high - low;
      const tr2 = Math.abs(high - prevClose);
      const tr3 = Math.abs(low - prevClose);

      trueRanges.push(Math.max(tr1, tr2, tr3));
    }

    const atr = trueRanges.reduce((sum, tr) => sum + tr, 0) / trueRanges.length;
    return atr;
  }
}
```

#### 2.2 동적 손절/익절 계산

```typescript
// src/auto-trading/service/AutoTradingService.ts
class AutoTradingService {
  private async calculateDynamicStopLoss(
    symbol: string,
    currentPrice: number,
    side: 'LONG' | 'SHORT',
  ): Promise<number> {
    const atr = await this.indicatorService.calculateATR(symbol, 14);
    const atrMultiplier = this.configService.get('STOP_LOSS_ATR_MULTIPLIER', 2);
    const minPercent = this.configService.get('STOP_LOSS_MIN_PERCENT', 1) / 100;
    const maxPercent = this.configService.get('STOP_LOSS_MAX_PERCENT', 5) / 100;

    const atrDistance = atr * atrMultiplier;
    const percentDistance = currentPrice * minPercent;
    const stopLossDistance = Math.max(atrDistance, percentDistance);

    if (side === 'LONG') {
      return currentPrice - stopLossDistance;
    } else {
      return currentPrice + stopLossDistance;
    }
  }

  private async calculateDynamicTakeProfit(
    symbol: string,
    currentPrice: number,
    side: 'LONG' | 'SHORT',
  ): Promise<number> {
    const stopLoss = await this.calculateDynamicStopLoss(
      symbol,
      currentPrice,
      side,
    );
    const riskRewardRatio = this.configService.get(
      'TAKE_PROFIT_RISK_REWARD_RATIO',
      2,
    );

    const stopLossDistance = Math.abs(currentPrice - stopLoss);
    const takeProfitDistance = stopLossDistance * riskRewardRatio;

    if (side === 'LONG') {
      return currentPrice + takeProfitDistance;
    } else {
      return currentPrice - takeProfitDistance;
    }
  }
}
```

### **3단계: Kelly Criterion 적용**

#### 3.1 거래 통계 수집

```typescript
// src/transaction/service/TransactionService.ts
class TransactionService {
  async getTradingStatistics(
    symbol: string,
    days: number = 30,
  ): Promise<TradingStats> {
    const trades = await this.getTradesBySymbol(symbol, days);

    const totalTrades = trades.length;
    const winningTrades = trades.filter((t) => t.pnl > 0);
    const losingTrades = trades.filter((t) => t.pnl < 0);

    const winRate = winningTrades.length / totalTrades;
    const avgWin =
      winningTrades.reduce((sum, t) => sum + t.pnl, 0) / winningTrades.length;
    const avgLoss = Math.abs(
      losingTrades.reduce((sum, t) => sum + t.pnl, 0) / losingTrades.length,
    );

    return { winRate, avgWin, avgLoss, totalTrades };
  }
}
```

#### 3.2 Kelly Criterion 계산

```typescript
// src/auto-trading/service/AutoTradingService.ts
class AutoTradingService {
  private calculateKellyPositionSize(stats: TradingStats): number {
    const { winRate, avgWin, avgLoss } = stats;

    if (avgLoss === 0 || winRate === 0) return 0.02; // 기본 2%

    // Kelly 공식: f = (bp - q) / b
    const b = avgWin / avgLoss; // 수익/손실 비율
    const p = winRate; // 승률
    const q = 1 - winRate; // 패률

    const kellyFraction = (b * p - q) / b;

    // 보수적 Kelly (50% 적용)
    const conservativeKelly = kellyFraction * 0.5;

    // 최소 0%, 최대 10% 제한
    return Math.max(0, Math.min(conservativeKelly, 0.1));
  }
}
```

### **4단계: API 및 대시보드**

#### 4.1 설정 관리 API

```typescript
// src/auto-trading/web/AutoTradingController.ts
@Controller('auto-trading')
export class AutoTradingController {
  @Get('config')
  async getTradingConfig() {
    return {
      positionSize: {
        type: this.configService.get('POSITION_SIZE_TYPE', 'DYNAMIC'),
        percentage: this.configService.get('POSITION_SIZE_PERCENT', 2),
        maxAmount: this.configService.get('POSITION_SIZE_MAX_AMOUNT', 1000),
        minAmount: this.configService.get('POSITION_SIZE_MIN_AMOUNT', 50),
      },
      stopLoss: {
        type: this.configService.get('STOP_LOSS_TYPE', 'ATR_BASED'),
        atrMultiplier: this.configService.get('STOP_LOSS_ATR_MULTIPLIER', 2),
        minPercent: this.configService.get('STOP_LOSS_MIN_PERCENT', 1),
        maxPercent: this.configService.get('STOP_LOSS_MAX_PERCENT', 5),
      },
      takeProfit: {
        type: this.configService.get('TAKE_PROFIT_TYPE', 'RISK_REWARD'),
        riskRewardRatio: this.configService.get(
          'TAKE_PROFIT_RISK_REWARD_RATIO',
          2,
        ),
        minPercent: this.configService.get('TAKE_PROFIT_MIN_PERCENT', 2),
        maxPercent: this.configService.get('TAKE_PROFIT_MAX_PERCENT', 10),
      },
    };
  }

  @Put('config')
  async updateTradingConfig(@Body() config: TradingConfigDto) {
    await this.autoTradingService.updateConfig(config);
    return { message: '설정이 업데이트되었습니다.' };
  }
}
```

#### 4.2 실시간 대시보드

```typescript
@Get('dashboard')
async getTradingDashboard() {
  const config = await this.getTradingConfig();
  const balances = await this.futuresService.getFuturesBalances();
  const positions = await this.futuresService.getActivePositions();
  const stats = await this.transactionService.getTradingStatistics('ALL', 30);

  return {
    config,
    account: {
      balances,
      totalBalance: balances.reduce((sum, b) => sum + b.totalBalance, 0),
      availableBalance: balances.reduce((sum, b) => sum + b.availableBalance, 0),
    },
    positions,
    performance: {
      totalTrades: stats.totalTrades,
      winRate: stats.winRate * 100,
      avgWin: stats.avgWin,
      avgLoss: stats.avgLoss,
      profitFactor: stats.avgWin / stats.avgLoss,
    }
  };
}
```

---

## 🔧 기술적 상세

### **환경변수 설정**

#### **포지션 크기 설정**

```bash
# 포지션 크기 타입 (FIXED | DYNAMIC)
POSITION_SIZE_TYPE=DYNAMIC

# 계좌 잔고 대비 비율 (%)
POSITION_SIZE_PERCENT=2

# 최대/최소 포지션 크기 (USD)
POSITION_SIZE_MAX_AMOUNT=1000
POSITION_SIZE_MIN_AMOUNT=50

# Kelly Criterion 설정
KELLY_CONSERVATIVE_FACTOR=0.5
KELLY_MAX_POSITION_SIZE=0.1
```

#### **손절/익절 설정**

```bash
# 손절 타입 (FIXED_PERCENT | ATR_BASED)
STOP_LOSS_TYPE=ATR_BASED

# ATR 기반 손절 설정
STOP_LOSS_ATR_MULTIPLIER=2
STOP_LOSS_MIN_PERCENT=1
STOP_LOSS_MAX_PERCENT=5

# 익절 타입 (FIXED_PERCENT | RISK_REWARD)
TAKE_PROFIT_TYPE=RISK_REWARD

# 리스크/리워드 비율
TAKE_PROFIT_RISK_REWARD_RATIO=2
TAKE_PROFIT_MIN_PERCENT=2
TAKE_PROFIT_MAX_PERCENT=10
```

#### **리스크 관리 설정**

```bash
# 리스크 관리 활성화
RISK_MANAGEMENT_ENABLED=true

# 거래당 최대 리스크 (%)
MAX_RISK_PER_TRADE=2

# 일일 최대 리스크 (%)
MAX_DAILY_RISK=5

# 최대 동시 포지션 수
MAX_CONCURRENT_POSITIONS=3
```

### **데이터 구조**

#### **TradingConfigDto**

```typescript
interface TradingConfigDto {
  positionSize: {
    type: 'FIXED' | 'DYNAMIC';
    percentage: number;
    maxAmount: number;
    minAmount: number;
  };
  stopLoss: {
    type: 'FIXED_PERCENT' | 'ATR_BASED';
    atrMultiplier: number;
    minPercent: number;
    maxPercent: number;
  };
  takeProfit: {
    type: 'FIXED_PERCENT' | 'RISK_REWARD';
    riskRewardRatio: number;
    minPercent: number;
    maxPercent: number;
  };
  riskManagement: {
    enabled: boolean;
    maxRiskPerTrade: number;
    maxDailyRisk: number;
    maxConcurrentPositions: number;
  };
}
```

#### **TradingStats**

```typescript
interface TradingStats {
  totalTrades: number;
  winRate: number;
  avgWin: number;
  avgLoss: number;
  profitFactor: number;
  sharpeRatio: number;
  maxDrawdown: number;
}
```

---

## 📡 API 설계

### **설정 관리 API**

#### **GET /auto-trading/config**

현재 자동매매 설정 조회

**응답 예시**:

```json
{
  "success": true,
  "data": {
    "positionSize": {
      "type": "DYNAMIC",
      "percentage": 2,
      "maxAmount": 1000,
      "minAmount": 50
    },
    "stopLoss": {
      "type": "ATR_BASED",
      "atrMultiplier": 2,
      "minPercent": 1,
      "maxPercent": 5
    },
    "takeProfit": {
      "type": "RISK_REWARD",
      "riskRewardRatio": 2,
      "minPercent": 2,
      "maxPercent": 10
    }
  }
}
```

#### **PUT /auto-trading/config**

자동매매 설정 업데이트

**요청 예시**:

```json
{
  "positionSize": {
    "type": "DYNAMIC",
    "percentage": 3,
    "maxAmount": 1500
  },
  "stopLoss": {
    "atrMultiplier": 2.5
  }
}
```

### **대시보드 API**

#### **GET /auto-trading/dashboard**

실시간 자동매매 대시보드

**응답 예시**:

```json
{
  "success": true,
  "data": {
    "config": {
      /* 설정 정보 */
    },
    "account": {
      "totalBalance": 10000,
      "availableBalance": 9500,
      "usedMargin": 500
    },
    "positions": [
      {
        "symbol": "BTCUSDT",
        "side": "LONG",
        "quantity": 0.001,
        "entryPrice": 50000,
        "currentPrice": 51000,
        "pnl": 10,
        "pnlPercent": 2
      }
    ],
    "performance": {
      "totalTrades": 150,
      "winRate": 65,
      "avgWin": 3.2,
      "avgLoss": 1.8,
      "profitFactor": 1.78
    }
  }
}
```

---

## 🧪 테스트 계획

### **1단계: 단위 테스트**

#### **포지션 크기 계산 테스트**

```typescript
describe('calculateDynamicPositionSize', () => {
  it('계좌 잔고 기반으로 올바른 포지션 크기를 계산해야 함', async () => {
    // Given
    const mockBalance = 10000; // $10,000
    const mockPrice = 50000; // $50,000
    const expectedPercentage = 0.02; // 2%

    // When
    const result = await service.calculateDynamicPositionSize(
      'BTCUSDT',
      mockPrice,
    );

    // Then
    const expectedAmount = mockBalance * expectedPercentage;
    const expectedQuantity = expectedAmount / mockPrice;
    expect(result).toBeCloseTo(expectedQuantity, 6);
  });
});
```

#### **ATR 기반 손절 계산 테스트**

```typescript
describe('calculateDynamicStopLoss', () => {
  it('ATR 기반으로 올바른 손절가를 계산해야 함', async () => {
    // Given
    const mockATR = 1000;
    const mockPrice = 50000;
    const mockMultiplier = 2;

    // When
    const result = await service.calculateDynamicStopLoss(
      'BTCUSDT',
      mockPrice,
      'LONG',
    );

    // Then
    const expectedStopLoss = mockPrice - mockATR * mockMultiplier;
    expect(result).toBe(expectedStopLoss);
  });
});
```

### **2단계: 통합 테스트**

#### **전체 자동매매 플로우 테스트**

```typescript
describe('AutoTrading Flow', () => {
  it('신호 발생 시 동적 설정으로 포지션을 진입해야 함', async () => {
    // Given
    const signal = { symbol: 'BTCUSDT', signal: 'STRONG_BUY' };
    const mockBalance = 10000;

    // When
    await service.handleTradingSignal(signal);

    // Then
    const position = await futuresService.getPosition('BTCUSDT');
    expect(position).toBeDefined();
    expect(position.quantity).toBeGreaterThan(0);

    // 동적 설정 확인
    const expectedAmount = mockBalance * 0.02; // 2%
    expect(position.notionalValue).toBeCloseTo(expectedAmount, 2);
  });
});
```

### **3단계: 성능 테스트**

#### **응답 시간 테스트**

```typescript
describe('Performance Tests', () => {
  it('포지션 크기 계산이 100ms 이내에 완료되어야 함', async () => {
    const startTime = Date.now();
    await service.calculateDynamicPositionSize('BTCUSDT', 50000);
    const endTime = Date.now();

    expect(endTime - startTime).toBeLessThan(100);
  });
});
```

---

## 🚀 배포 및 모니터링

### **배포 단계**

#### **1. 환경변수 설정**

```bash
# .env.production 파일 생성
POSITION_SIZE_TYPE=DYNAMIC
POSITION_SIZE_PERCENT=2
POSITION_SIZE_MAX_AMOUNT=1000
STOP_LOSS_TYPE=ATR_BASED
STOP_LOSS_ATR_MULTIPLIER=2
TAKE_PROFIT_TYPE=RISK_REWARD
TAKE_PROFIT_RISK_REWARD_RATIO=2
```

#### **2. 점진적 배포**

1. **1단계**: 기존 설정 유지, 로깅만 추가
2. **2단계**: 동적 포지션 크기 활성화 (소액으로 테스트)
3. **3단계**: ATR 기반 손절/익절 활성화
4. **4단계**: Kelly Criterion 적용

#### **3. 롤백 계획**

```bash
# 긴급 롤백 명령어
POSITION_SIZE_TYPE=FIXED
STOP_LOSS_TYPE=FIXED_PERCENT
TAKE_PROFIT_TYPE=FIXED_PERCENT
```

### **모니터링 지표**

#### **성능 지표**

- 포지션 크기 계산 응답 시간
- ATR 계산 응답 시간
- API 응답 시간

#### **거래 지표**

- 평균 포지션 크기
- 손절/익절 실행 비율
- 리스크/리워드 비율 달성률
- Kelly Criterion 적용 효과

#### **알림 설정**

```typescript
// 텔레그램 알림 예시
await this.notificationService.sendTelegramMessage(
  `🚨 자동매매 설정 변경\n` +
    `포지션 크기: ${oldConfig.percentage}% → ${newConfig.percentage}%\n` +
    `손절: ${oldConfig.atrMultiplier}배 → ${newConfig.atrMultiplier}배\n` +
    `익절: ${oldConfig.riskRewardRatio}:1 → ${newConfig.riskRewardRatio}:1`,
);
```

---

## 📈 기대 효과

### **1. 리스크 관리 개선**

- 계좌 잔고에 맞는 적절한 포지션 크기
- 시장 변동성에 따른 동적 손절/익절
- 일일 리스크 한도 관리

### **2. 수익률 향상**

- Kelly Criterion을 통한 최적 포지션 크기
- ATR 기반 정확한 손절/익절
- 리스크/리워드 비율 최적화

### **3. 운영 효율성**

- 실시간 설정 조절
- 웹 대시보드를 통한 모니터링
- 자동화된 리스크 관리

---

## ⚠️ 주의사항

### **리스크 관리**

- 초기에는 보수적 설정으로 시작
- 점진적으로 설정 조정
- 지속적인 모니터링 필수

### **테스트**

- 실제 거래 전 충분한 백테스팅
- 소액으로 실시간 테스트
- 다양한 시장 상황에서 검증

### **백업**

- 기존 설정 백업
- 롤백 절차 준비
- 긴급 정지 기능 구현

---

## 📞 지원 및 문의

개선 프로세스 관련 문의사항이 있으시면 언제든 연락주세요!

**담당자**: 개발팀  
**이메일**: dev@quant-backend.com  
**슬랙**: #auto-trading-improvement
